<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PHP | Programming Rambling]]></title>
  <link href="http://mrzard.github.com/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://mrzard.github.com/"/>
  <updated>2013-03-25T11:38:41+01:00</updated>
  <id>http://mrzard.github.com/</id>
  <author>
    <name><![CDATA[Gonzalo MÃ­guez]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL Query to Export Prestashop Data to a Shopify CSV]]></title>
    <link href="http://mrzard.github.com/blog/2013/02/13/export-prestashop-data-to-a-shopify-csv/"/>
    <updated>2013-02-13T18:19:00+01:00</updated>
    <id>http://mrzard.github.com/blog/2013/02/13/export-prestashop-data-to-a-shopify-csv</id>
    <content type="html"><![CDATA[<p>If you find yourself migrating your shop from Prestashop to Shopify, you can
use this query. It was written for an old version of Prestashop, but you probably
won't have much trouble adapting it to newer versions.</p>

<p>Also, take in consideration this query only outputs basic data, no variants,
colors, etc. Also check which values do you need for 'variant requires shipping',
ID_LANG, etc.</p>

<pre><code>SELECT pl.link_rewrite as `Handle`, pl.name as `Title`, pl.description as `Body 
(HTML)`, 'VENDORNAME' as `Vendor`, pcl.`name` as `Type`, t.`name` as Tags, 
'' as `Option1 Name`, '' as `Option1 Value`, '' as `Option2 Name`, '' as `Option2 
Value`, '' as `Option3 Name`, '' as `Option3 Value`, '' as `Variant SKU`, p.weight 
* 1000 as `Variant Grams`, '' as `Variant Inventory Tracker`, p.`quantity` 
as `Variant Inventory Qty`, 'deny' as `Variant Inventory Policy`, 'manual' 
as `Variant Fulfillment Service`, p.price as `Variant Price`, p.price_before 
as `Variant Compare At Price`, 'true' as `Variant Requires Shipping`, 'true' 
as `Variant Taxable`, '' as `Image Src` FROM `ps_product` p INNER JOIN `ps_product_lang` 
pl ON pl.`id_product` = p.`id_product` LEFT JOIN `ps_product_tag` pt ON pt.`id_product` 
= p.`id_product` LEFT JOIN `ps_tag` t ON t.`id_tag` = pt.`id_tag` INNER JOIN 
`ps_image` pi ON pi.`id_product` = p.`id_product` INNER JOIN `ps_category_lang` 
pcl ON pcl.`id_category` = p.`id_category_default` WHERE pl.`id_lang` = ID_LANG 
AND pcl.`id_lang` = ID_LANG AND p.`id_category_default` IN (SELECT `id_category` 
FROM `ps_category` WHERE `active` = 1) AND p.`active` = 1 GROUP BY p.`id_product`; 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate CSRF token programatically in Symfony 2]]></title>
    <link href="http://mrzard.github.com/blog/2012/08/08/generate-csrf-token-programatically-in-symfon/"/>
    <updated>2012-08-08T16:28:29+02:00</updated>
    <id>http://mrzard.github.com/blog/2012/08/08/generate-csrf-token-programatically-in-symfon</id>
    <content type="html"><![CDATA[<p>If you find yourself in the need of generating a CSRF token for a 'built' Request
or something in that fashion, you can do it rather easily:</p>

<pre><code>$csrfProvider = $this-&gt;container-&gt;get('form.csrf_provider'); $csrfToken = $csrfProvider-&gt;generateCsrfToken('unknown'); 
</code></pre>

<p><em>'unknown'</em> is the default 'intention' of CSRF tokens in Symfony2, change 'unknown'
for the correct intention if you are using that option.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate a valid Google Premier signature in PHP]]></title>
    <link href="http://mrzard.github.com/blog/2011/12/12/generate-a-valid-google-premier-signature-in/"/>
    <updated>2011-12-12T11:23:00+01:00</updated>
    <id>http://mrzard.github.com/blog/2011/12/12/generate-a-valid-google-premier-signature-in</id>
    <content type="html"><![CDATA[<p>Google Premier requires for you to generate a signature over the URL you're
going to ask for, then send that signature alongside the request. Here is how
to do it, as there is no PHP example in the <a href="http://code.google.com/intl/es-ES/apis/maps/documentation/webservices/#URLSigning">Google Primer URL Signature documentation</a></p>

<p>In this code snippet we assume:</p>

<ul>
<li>$request_url has the url that will be using the Google Premier service (for example, Static Maps API). It also already has the client param, sensor param, etc.</li>
<li>$signature_key has the key provided to you by Google</li>
<li>You are running this snippet from an authorized domain</li>
<li><p>Props to <a href="http://stackoverflow.com/questions/3125410/trying-to-digitally-sign-via-hmac-sha1-with-php">ZZ Coder at StackOverflow</a></p>

<p>  $url_parts = parse_url($request_url); $signable_part = $url_parts['path'].'?'.$url_parts['query'];
  $decoded_key = base64_decode(strtr($signature_key, '-<em>', '+/'); $url_signature
  = hash_hmac('sha1', $signable_part, $decoded_key), true); $base64signature
  = strtr(base64_encode($url_signature), '+/', '-</em>'); $signature_param = '&amp;signature='.urlencode($base64signature);</p></li>
</ul>


<p>'Strange' things in this snippet:</p>

<ul>
<li>Why the strtr()? Because Google uses URL-Safe base64</li>
<li>Why the true param at the end of hash_hmac? Because we need it the signature to be returned in binary before base64encondig it.</li>
</ul>


<p>Then you just have to append $signature_param to your original request (which
we've assumed is in $request_url) to have a correctly signed Google Premier
request.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP namespaces simple explanation]]></title>
    <link href="http://mrzard.github.com/blog/2011/10/25/php-namespaces-simple-explanation/"/>
    <updated>2011-10-25T11:58:00+02:00</updated>
    <id>http://mrzard.github.com/blog/2011/10/25/php-namespaces-simple-explanation</id>
    <content type="html"><![CDATA[<p>This is one of the most clear and comprehensible articles on namespaces I have
ever seen. If you're having trouble understanding the logic behind them or
how to use them, please do take a look at it:</p>

<p><a href="http://phpmaster.com/php-namespaces/">PHP Namespaces on PHPMaster.com</a> by Moshe Teutsch (<a href="http://phpmaster.com/author/moteutsch/">http://phpmaster.com/author/moteutsch/</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcache vs Memcached (PHP): A simple explanation]]></title>
    <link href="http://mrzard.github.com/blog/2011/05/06/memcache-vs-memcached-php-a-simple-explanatio/"/>
    <updated>2011-05-06T09:19:00+02:00</updated>
    <id>http://mrzard.github.com/blog/2011/05/06/memcache-vs-memcached-php-a-simple-explanatio</id>
    <content type="html"><![CDATA[<p>In a nutshell:</p>

<p>memcache is older, less mantained.</p>

<p>memcached is newer, developed by Digg people and generally preferred. Also
it seems it is more configurable and has more options.</p>

<p>Complete explanation and opinions: <a href="http://serverfault.com/questions/63383/memcache-vs-memcached">http://serverfault.com/questions/63383/memcache-vs-memcached</a></p>

<p>Client comparision: <a href="http://code.google.com/p/memcached/wiki/PHPClientComparison">http://code.google.com/p/memcached/wiki/PHPClientComparison</a></p>

<p>PECL pages:<br/>
<a href="http://pecl.php.net/package/memcache">http://pecl.php.net/package/memcache</a><br/>
<a href="http://pecl.php.net/package/memcached">http://pecl.php.net/package/memcached</a></p>
]]></content>
  </entry>
  
</feed>
